# -*- coding: utf-8 -*-
"""Computacion_paralelo.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QDkIIbizhLo6poJnwTOmaHcmk_25WHyl
"""

pip install cplex

pip install docplex

import numpy as np
import pandas as pd
import itertools
import multiprocessing
import matplotlib.pyplot as plt
import time
plt.style.use('dark_background')
from docplex.mp.model import Model

df=pd.read_excel('/content/coordenadas.xlsx')
df.rename(columns={'Unnamed: 0':'Ciudad'},inplace=True)

"""**Cálculo en serie**"""

#Seleccionar ciudades y coordenadas
n=10
ciudades=df['Ciudad'][:n].tolist()
coordenadas=df[['Latitud','Longitud']][:n].values.tolist()

#Distancia euclidiana
def distancia(p1,p2):
    return 75*np.linalg.norm(np.array(p1)-np.array(p2))

#Distancia total
def calcular_distancia(recorrido):
    d=0
    for i in range(len(recorrido)-1):
        d+=distancia(coordenadas[recorrido[i]],coordenadas[recorrido[i+1]])
    d+=distancia(coordenadas[recorrido[-1]],coordenadas[recorrido[0]])
    return d

#Permutaciones
permutaciones=itertools.permutations(range(len(ciudades)))
mejor_distancia=float('inf')
mejor_recorrido=None

#Tiempo de inicio de cómputos
tiempo_inicial=time.time()
#Evaluar rutas
for p in permutaciones:
    d=calcular_distancia(p)
    if d<mejor_distancia:
        mejor_distancia=d
        mejor_recorrido=p

tiempo_final=time.time()
duracion=tiempo_final-tiempo_inicial
print("Duración de la ejecución:",duracion,"segundos")

#Resultado
print("Mejor recorrido:",[ciudades[i] for i in mejor_recorrido])
print("Distancia total del mejor recorrido:",mejor_distancia)

#Gráfica de la ruta
ruta=[coordenadas[i] for i in mejor_recorrido]
latitudes=[75*p[0] for p in ruta]
longitudes=[75*p[1] for p in ruta]
latitudes.append(latitudes[0])
longitudes.append(longitudes[0])

plt.figure(figsize=(10,7))
plt.plot(longitudes,latitudes,marker='o',color='indigo',linestyle='-',markersize=6)
plt.title('Ruta óptima del TSP',fontsize=16)
plt.xlabel('x (km)',fontsize=12)
plt.ylabel('y (km)',fontsize=12)

for i,c in enumerate(mejor_recorrido):
    plt.text(longitudes[i],latitudes[i],ciudades[c],fontsize=9,ha='right')

plt.show()

"""**Cálculo en paralelo**"""

#Seleccionar ciudades
n=10
ciudades=df['Ciudad'][:n].tolist()
coordenadas=df[['Latitud','Longitud']][:n].values.tolist()

#Distancia euclidiana
def distancia(p1,p2):
    return 75*np.linalg.norm(np.array(p1)-np.array(p2))

#Distancia total
def calcular_distancia(ruta):
    d=0
    for i in range(len(ruta)-1):
        d+=distancia(coordenadas[ruta[i]],coordenadas[ruta[i+1]])
    d+=distancia(coordenadas[ruta[-1]],coordenadas[ruta[0]])
    return d

#Evaluar subconjunto
def evaluar(permutaciones):
    mejor_d=float('inf')
    mejor_ruta=None
    for p in permutaciones:
        d=calcular_distancia(p)
        if d<mejor_d:
            mejor_d=d
            mejor_ruta=p
    return mejor_ruta,mejor_d

#Paralelizar cálculo
def paralelizar():
    perm=list(itertools.permutations(range(len(ciudades))))
    n_proc=multiprocessing.cpu_count()
    tam=len(perm)//n_proc
    partes=[perm[i:i+tam] for i in range(0,len(perm),tam)]
    with multiprocessing.Pool(processes=n_proc) as pool:
        resultados=pool.map(evaluar,partes)
    mejor_d=float('inf')
    mejor_ruta=None
    for r,d in resultados:
        if d<mejor_d:
            mejor_d=d
            mejor_ruta=r
    return mejor_ruta,mejor_d


#Ejecutar búsqueda
tiempo_inicial=time.time()
mejor_ruta,mejor_d=paralelizar()
tiempo_final=time.time()
duracion=tiempo_final-tiempo_inicial
print("Duración de la ejecución:",duracion,"segundos")

#Resultado
print("Mejor recorrido:",[ciudades[i] for i in mejor_ruta])
print("Distancia total del mejor recorrido:",mejor_d)

#Graficar ruta
ruta=[coordenadas[i] for i in mejor_ruta]
latitudes=[75*p[0] for p in ruta]
longitudes=[75*p[1] for p in ruta]
latitudes.append(latitudes[0])
longitudes.append(longitudes[0])

plt.figure(figsize=(10,8))
plt.plot(longitudes,latitudes,marker='o',color='indigo',linestyle='-',markersize=6)
plt.title('Ruta óptima del TSP',fontsize=16)
plt.xlabel('x (km)',fontsize=12)
plt.ylabel('y (km)',fontsize=12)

for i,c in enumerate(mejor_ruta):
    plt.text(longitudes[i],latitudes[i],ciudades[c],fontsize=9,ha='right')

plt.show()

"""**Cálculo con la librería Cplex**"""

#Seleccionar ciudades
n=10
ciudades = df['Ciudad'][:n].tolist()


x=75*np.array(df['Longitud'][:n])
y=75*np.array(df['Latitud'][:n])

#Distancia euclidiana
def distancia(ciudad1, ciudad2):
    return np.hypot(x[ciudad1]-x[ciudad2],y[ciudad1]-y[ciudad2])


arcos=[(i,j) for i in range(len(ciudades)) for j in range(len(ciudades)) if i!=j]

distancia={(i,j): np.hypot(x[i]-x[j],y[i]-y[j]) for i,j in arcos}

#Crear el modelo de CPLEX
mdl=Model('TSP')

#Variables de decisión

x=mdl.binary_var_dict(arcos,name='x')
d=mdl.continuous_var_dict(ciudades,name='d')

mdl.minimize(mdl.sum(distancia[i]*x[i] for i in arcos))

for i,c in enumerate(ciudades):
    mdl.add_constraint(mdl.sum(x[(k,j)] for k,j in arcos if k==i)==1,
                       ctname='out_%d'%i)

for i,c in enumerate(ciudades):
    mdl.add_constraint(mdl.sum(x[(k,j)] for k, j in arcos if j==i)==1,  # Use index i
                       ctname='in_%d' %i)

for i,j in arcos:
    if j!= 0:
        mdl.add_indicator(x[(i, j)],d[ciudades[i]]+1==d[ciudades[j]],
                          name='order_(%d,_%d)' % (i,j))

#Visualizar modelo matemático
print(mdl.export_to_string())

mdl.parameters.timelimit=520
mdl.parameters.mip.strategy.branch=1
mdl.parameters.mip.tolerances.mipgap=0.15

#Resolver el modelo
solucion=mdl.solve(log_output=True)

mdl.get_solve_status()

#Solución óptima
solucion.display()